<!DOCTYPE html>
<html>
<head>
    <title>Audio Track Debug</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .log { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>üéµ Audio Track Debug Console</h1>

    <div>
        <button onclick="testBundledProtocol()">Test Bundled Protocol</button>
        <button onclick="testAudioTracks()">Test Audio Tracks</button>
        <button onclick="testCache()">Test Cache</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log" class="log"></div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        async function testBundledProtocol() {
            log('üîç Testing bundled protocol access...');

            try {
                // Test if we can access the bundled protocol
                const response = await fetch('bundled://out02.cdr');
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    log(`‚úÖ Bundled protocol working! out02.cdr: ${data.byteLength} bytes`, 'success');
                } else {
                    log(`‚ùå Bundled protocol failed: ${response.status}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Bundled protocol error: ${error.message}`, 'error');
            }
        }

        async function testAudioTracks() {
            log('üéµ Testing audio track loading...');

            const audioTracks = ['out02.cdr', 'out03.cdr', 'out04.cdr'];

            for (let i = 0; i < audioTracks.length; i++) {
                const trackName = audioTracks[i];
                try {
                    log(`üîÑ Testing ${trackName}...`);
                    const response = await fetch(`bundled://${trackName}`);
                    if (response.ok) {
                        const data = await response.arrayBuffer();
                        log(`‚úÖ ${trackName}: ${data.byteLength} bytes`, 'success');

                        // Test WAV conversion
                        const wavBuffer = convertCdrToWav(data);
                        log(`üéº ${trackName} ‚Üí WAV: ${wavBuffer.byteLength} bytes`, 'success');

                        // Test cache storage
                        const musicTrackName = `musictrack${i}`;
                        await cachePutData(musicTrackName, wavBuffer);
                        log(`üíæ Cached as ${musicTrackName}`, 'success');

                    } else {
                        log(`‚ùå ${trackName}: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`‚ùå ${trackName}: ${error.message}`, 'error');
                }
            }
        }

        async function testCache() {
            log('üíæ Testing cache access...');

            for (let i = 0; i < 3; i++) {
                const musicTrackName = `musictrack${i}`;
                try {
                    const cachedTrack = await cacheGetData(musicTrackName);
                    if (cachedTrack) {
                        log(`‚úÖ ${musicTrackName}: ${cachedTrack.byteLength} bytes`, 'success');
                    } else {
                        log(`‚ùå ${musicTrackName}: Not found in cache`, 'error');
                    }
                } catch (error) {
                    log(`‚ùå ${musicTrackName}: ${error.message}`, 'error');
                }
            }
        }

        function convertCdrToWav(rawAudioBuffer) {
            const headerLen = 44;
            const rawDataLength = rawAudioBuffer.byteLength;
            const wavBuffer = new ArrayBuffer(headerLen + rawDataLength);
            const wavArray = new Uint8Array(wavBuffer);
            const wavView = new DataView(wavBuffer);

            // Write WAV header
            const encoder = new TextEncoder();
            wavArray.set(encoder.encode('RIFF'), 0);
            wavView.setUint32(4, rawDataLength + 8 + 24 + 4, true);
            wavArray.set(encoder.encode('WAVE'), 8);
            wavArray.set(encoder.encode('fmt '), 12);
            wavView.setUint32(16, 16, true);
            wavView.setUint16(20, 1, true);
            wavView.setUint16(22, 2, true);
            wavView.setUint32(24, 44100, true);
            wavView.setUint32(28, 44100 * 4, true);
            wavView.setUint16(32, 4, true);
            wavView.setUint16(34, 16, true);
            wavArray.set(encoder.encode('data'), 36);
            wavView.setUint32(40, rawDataLength, true);

            // Copy the raw audio data after the header
            wavArray.set(new Uint8Array(rawAudioBuffer), headerLen);

            return wavBuffer;
        }

        // Mock cache functions for testing
        const cache = new Map();

        async function cachePutData(key, data) {
            cache.set(key, data);
            log(`üíæ Cache PUT: ${key} (${data.byteLength} bytes)`);
        }

        async function cacheGetData(key) {
            const data = cache.get(key);
            if (data) {
                log(`üíæ Cache GET: ${key} (${data.byteLength} bytes)`);
            } else {
                log(`üíæ Cache GET: ${key} (not found)`);
            }
            return data;
        }

        log('üöÄ Audio Track Debug Console Ready!', 'success');
    </script>
</body>
</html>
